(defun util::range  (start end step / i res)
  (setq	i   start
	res '())
  (while (< i end)
    (setq res (cons i res)
	  i   (+ i step)))
  (reverse res))

(defun util::sset->list	 (sset / res)
  (setq res '())
  (foreach i  (util::range 0 (sslength sset) 1)
    (setq res (cons (ssname sset i)
		    res)))
  res)

(defun util::containsp	(alist elem eq-function)
  (if (null alist)
    nil
    (vl-some '(lambda (x) (eq-function x elem))
	     alist)))

(defun util::search  (pred alist)
  (cond	((null alist) nil)
	((apply pred (list (car alist)))
	 (car alist))
	(T (util::search pred (cdr alist)))))

(defun util::sorted  (alist pred)
  (mapcar '(lambda (i) (nth i alist))
	  (vl-sort-i alist pred)))

(defun util::string->number  (str / n pow)
  (defun ascii-code->digit  (ascii-code)
    (cond ((and	(>= ascii-code 48)
		(<= ascii-code 57))
	   (- ascii-code 48))
	  ((= ascii-code 46) 'dot)
	  (t 'not-a-digit)))
  (defun skip-letters  (alist / alist)
    (setq ch (car alist))
    (cond ((null alist) nil)
	  ((eq (ascii-code->digit ch) 'not-a-digit)
	   (skip-letters (cdr alist)))
	  (t alist)))
  (defun read-integer-part  (alist / ch)
    (cond ((null alist) nil)
	  ((numberp (setq ch (ascii-code->digit (car alist))))
	   (setq n (+ (* n 10)
		      ch))
	   (read-integer-part (cdr alist)))
	  ((eq ch 'dot) (cdr alist))
	  (t (cdr alist))))
  (defun read-fractional-part  (alist / ch)
    (cond ((null alist) nil)
	  ((numberp (setq ch (ascii-code->digit ch)))
	   (setq n   (+	(* n 10)
			ch)
		 pow (* pow 10))
	   (read-integer-part (cdr alist)))
	  (t nil)))
  (setq	n   0.0
	pow 1.0)
  (read-fractional-part
    (read-integer-part
      (skip-letters
	(vl-string->list str))))
  (/ n pow))

(defun util::get-maximum (cmpf alist / curr)
  (setq curr (car alist))
  (foreach elem alist
    (if (> (apply cmpf (list elem))
	   (apply cmpf (list curr)))
      (setq curr elem)))
  curr)

(defun util::get-minimum (cmpf alist / curr)
  (setq curr (car alist))
  (foreach elem alist
    (if (< (apply cmpf (list elem))
	   (apply cmpf (list curr)))
      (setq curr elem)))
  curr)

(defun util::list< (list1 list2 prec)
  (cond ((null list1) nil)
	((null list2) T)
    	((< (car list1) (car list2)) T)
	((equal (car list1)
		(car list2)
		prec)
	 (util::list< (cdr list1) (cdr list2) prec))
	(T nil)))

(defun util::list=  (list1 list2 prec)
  (cond	((and (null list1)
	      (null list2))
	 t)
	((equal	(car list1)
		(car list2)
		prec)
	 (util::list= (cdr list1) (cdr list2) prec))
	(t nil)))

(defun util::in-list  (elt lst)
  (cond	((null elt)
	 t)
	((null lst)
	 nil)
	((eq (elt (car lst)))
	 t)
	(t
	 (util::in-list elt (cdr lst)))))

(defun util::uo-list= (l1 l2 precision)
  ;;List equality operation ignoring the order of elements
  (util::list= (util::sorted l1 '<) (util::sorted l2 '<) precision))

(defun util::int-list->str (alist)
  (apply 'strcat (mapcar 'itoa alist)))